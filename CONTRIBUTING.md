# Contributing

## Development Setup

```bash
git clone https://github.com/dw218192/repokit.git
cd repokit
ln -sfn "$PWD" test_driver/tools/framework   # or New-Item -ItemType Junction on Windows
./bootstrap.sh                                # or bootstrap.ps1
cd test_driver && ./repo test --verbose
```

The `test_driver/` directory is a dogfooding project — it consumes repokit as if it were a real consumer. Tests and the `publish` tool both run from there.

## Initialization

### Bootstrap flow

The bootstrap script (`bootstrap.sh` / `bootstrap.ps1`) handles first-time setup:

1. Installs [uv](https://docs.astral.sh/uv/) into `_tools/bin/` if not already present.
2. Creates a Python venv at `_tools/venv/`.
3. Runs `./repo init` to generate deps and sync.

### Init flow

`./repo init` generates `tools/pyproject.toml` from the framework's dependency definitions and the project's config, then runs `uv sync` to install everything into the venv. Specifically:

1. Reads core deps from the framework's `pyproject.toml` `[project].dependencies`.
2. Reads feature groups from `[dependency-groups]`, filtered by `repo.features` in `config.yaml`.
3. Collects project deps from `repo.extra_deps` in `config.yaml` and `RepoTool.deps` on any registered tools.
4. Writes all of the above into `tools/pyproject.toml`.
5. Runs `uv sync` against that file to install into `_tools/venv/`.

Run `./repo init` again after changing `repo.features`, `repo.extra_deps`, or `RepoTool.deps` on a custom tool.

### Why two pyproject.toml files

- The **framework's** `pyproject.toml` (repo root) is the source of truth for available deps and feature groups. It defines core deps in `[project].dependencies` and optional feature groups (cpp, python) in `[dependency-groups]`.
- The **generated** `tools/pyproject.toml` is project-specific and auto-generated by `repo init`. It combines core deps + selected features + project deps into a single file for `uv sync`. Don't edit it by hand — it gets overwritten on every `./repo init`.

## Release Scheme

Repokit uses a two-branch model because it's consumed as a **git submodule**, not a package registry artifact. The `publish` tool in `test_driver/` acts as a packager — it strips dev-only files from `main` and produces a clean `release` branch that consumers point their submodule at.

### How it works

```
main (development)          release (packaged artifact)
  |                              |
  |  commit A                    |
  |  commit B                    |
  |  bump version in pyproject    |
  |  push to main                |
  |      |                       |
  |   CI: test ───> pass ──> publish
  |                              |
  |                         strip dev files, copy the rest
  |                         commit "v1.2.0: ..."
  |                         tag v1.2.0
  |                         push release + tag
```

- **`main`** — development branch. Has tests, CI config, dev tooling, everything.
- **`release`** — the packaged output. This is an **orphan branch with intentionally unrelated history** — it shares no common ancestor with `main`. Think of it like a `dist/` directory that happens to live in a git branch. Each release commit is a full snapshot of the runtime files, not a merge or cherry-pick from `main`.

### Why not just tag main?

Consumers add repokit as a submodule. If they tracked `main`, they'd pull in `test_driver/`, `.github/`, and other dev-only files. A separate orphan branch gives consumers a clean tree with only runtime files — no dev history, no dev artifacts.

### Publishing a release

1. Bump `version` in `pyproject.toml` (semver, e.g. `1.2.0`)
2. Commit and push to `main`
3. CI runs tests, then `./repo publish --push` which:
   - Checks out the `release` branch (creates it as an orphan if needed)
   - Removes all files, then copies only non-excluded files from `main`
   - Commits with message `v1.2.0: <main commit subject> (from main <sha>)`
   - Tags as `v1.2.0`
   - Pushes `release` branch and tag

If the tag already exists, publish is a no-op. If there are no file changes compared to the previous release, it skips the commit.
