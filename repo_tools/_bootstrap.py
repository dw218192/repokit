"""Stdlib-only bootloader for repo init.

Generates tools/pyproject.toml from the framework's pyproject.toml and runs
``uv sync``.  No third-party imports — bootstrap calls this before any pip
packages are installed.

Tool-declared deps are collected via ``RepoTool.deps`` and passed in by the
caller (e.g. InitTool).

Usage (from bootstrap scripts):
    python -m repo_tools._bootstrap <framework_dir> <workspace_root> [<uv_path>]
"""

from __future__ import annotations

import os
import shutil
import subprocess
import sys
import textwrap
import tomllib
from pathlib import Path

from .gitignore import patch_gitignore


def find_uv(workspace_root: Path) -> str | None:
    """Locate the uv executable: _tools/bin first, then PATH."""
    suffix = ".exe" if sys.platform == "win32" else ""

    tools_bin = workspace_root / "_tools" / "bin" / f"uv{suffix}"
    if tools_bin.exists():
        return str(tools_bin)

    return shutil.which("uv")


def load_framework_pyproject(framework_root: Path) -> dict:
    """Load and parse the framework pyproject.toml."""
    path = framework_root / "pyproject.toml"
    if not path.exists():
        print(f"ERROR: {path} not found", file=sys.stderr)
        sys.exit(1)
    return tomllib.loads(path.read_text(encoding="utf-8"))


def collect_feature_groups(
    framework_data: dict, features: list[str],
) -> dict[str, list[str]]:
    """Return the subset of [dependency-groups] matching *features*.

    If *features* is empty, returns all groups.
    """
    all_groups: dict[str, list[str]] = framework_data.get("dependency-groups", {})

    if not features:
        return dict(all_groups)

    selected: dict[str, list[str]] = {}
    for name in features:
        if name in all_groups:
            selected[name] = list(all_groups[name])
        else:
            print(f"WARNING: unknown feature '{name}'", file=sys.stderr)
    return selected



_PYPROJECT_TEMPLATE = textwrap.dedent("""\
    # Auto-generated by repokit — do not edit.

    [project]
    name = "project-tools"
    version = "0.0.0"
    requires-python = ">=3.11"
    dependencies = []

    [dependency-groups]
    {groups}

    [tool.uv]
    package = false
    default-groups = [{default_groups}]
""")


def write_pyproject(
    path: Path,
    groups: dict[str, list[str]],
) -> None:
    """Write the generated tools/pyproject.toml."""
    def _q(items: list[str]) -> str:
        return ", ".join(f'"{d}"' for d in items)

    content = _PYPROJECT_TEMPLATE.format(
        groups="\n".join(
            f"{name} = [{_q(deps)}]"
            for name, deps in sorted(groups.items())
        ),
        default_groups=_q(sorted(groups)),
    )

    path.parent.mkdir(parents=True, exist_ok=True)
    path.write_text(content, encoding="utf-8")


def uv_sync(uv: str, project_dir: Path, venv_dir: Path) -> None:
    """Run uv sync with UV_PROJECT_ENVIRONMENT pointing to the venv."""
    env = {**os.environ, "UV_PROJECT_ENVIRONMENT": str(venv_dir)}
    cmd = [uv, "sync", "--project", str(project_dir)]
    result = subprocess.run(cmd, env=env)
    if result.returncode != 0:
        print("ERROR: uv sync failed", file=sys.stderr)
        sys.exit(1)


def run(
    framework_root: Path,
    workspace_root: Path,
    uv: str | None = None,
    features: list[str] | None = None,
    tool_deps: list[str] | None = None,
) -> None:
    """Generate tools/pyproject.toml and run uv sync.

    *features*: list of enabled features, or None/empty for all.
    *tool_deps*: deps declared by registered tools via ``RepoTool.deps``.
    """
    if uv is None:
        uv = find_uv(workspace_root)
    if uv is None:
        print("ERROR: uv not found", file=sys.stderr)
        sys.exit(1)

    fw_data = load_framework_pyproject(framework_root)
    core_deps = list(fw_data.get("project", {}).get("dependencies", []))
    groups: dict[str, list[str]] = {"core": core_deps}
    groups.update(collect_feature_groups(fw_data, features or []))
    if tool_deps:
        groups["tools"] = tool_deps

    tools_pyproject = workspace_root / "tools" / "pyproject.toml"

    write_pyproject(tools_pyproject, groups)
    print(f"Generated {tools_pyproject}")

    venv_dir = workspace_root / "_tools" / "venv"
    uv_sync(uv, tools_pyproject.parent, venv_dir)

    patch_gitignore(workspace_root / ".gitignore")


def write_shims(
    framework_root: Path,
    workspace_root: Path,
) -> None:
    """Generate ./repo shims (bash + Windows cmd).

    Called during bootstrap after the venv exists.  Uses sys.executable
    to locate the venv Python — the caller must be running inside the venv.
    """
    py = Path(sys.executable)
    venv_bin = py.parent

    def _posix(p: Path) -> str:
        return str(p).replace("\\", "/")

    # bash shim (Linux/macOS, Git Bash on Windows)
    bash_shim = workspace_root / "repo"
    bash_shim.write_text(
        f"#!/bin/bash\n"
        f'export PATH="{_posix(venv_bin)}:$PATH"\n'
        f'PYTHONPATH="{_posix(framework_root)}" '
        f'exec "{_posix(py)}" -m repo_tools.cli '
        f'--workspace-root "{_posix(workspace_root)}" "$@"\n',
        encoding="utf-8",
        newline="\n",
    )
    try:
        bash_shim.chmod(0o755)
    except OSError:
        pass

    if sys.platform == "win32":
        cmd_shim = workspace_root / "repo.cmd"
        cmd_shim.write_text(
            f"@echo off\r\n"
            f'set "PATH={venv_bin};%PATH%"\r\n'
            f'set "PYTHONPATH={framework_root}"\r\n'
            f'"{py}" -m repo_tools.cli '
            f'--workspace-root "{workspace_root}" %*\r\n',
            encoding="utf-8",
            newline="",
        )


if __name__ == "__main__":
    if len(sys.argv) < 3:
        print(f"Usage: {sys.argv[0]} <framework_dir> <workspace_root> [<uv_path>]",
              file=sys.stderr)
        sys.exit(1)

    fw = Path(sys.argv[1])
    ws = Path(sys.argv[2])
    uv_path = sys.argv[3] if len(sys.argv) > 3 else None
    run(fw, ws, uv_path)
    write_shims(fw, ws)

    # Re-run init with full config awareness (extra_deps, features).
    # The first run() installed core deps (pyyaml, click) so the CLI is
    # now importable.  This second sync only adds the delta.
    env = {**os.environ, "PYTHONPATH": str(fw)}
    subprocess.run(
        [sys.executable, "-m", "repo_tools.cli",
         "--workspace-root", str(ws), "init"],
        env=env,
    )

    print(f"Run ./repo --help to get started.")
